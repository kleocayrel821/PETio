{% extends "marketplace/base_marketplace.html" %}

{#
  Marketplace Messages Page (Redesigned)
  Purpose: Provide a professional, responsive inbox + chat UI for marketplace conversations.
  - Preserves existing Django blocks and API endpoints.
  - Enhances visual design with modern components, avatars, badges, and clean layout.
  - Adds loading skeletons, empty states, typing indicator, debounced search, and poller backoff.
  - Keeps backward-compatible JavaScript functions and REST calls.
#}

{% block marketplace_header_section %}{% endblock %}
{% block marketplace_title %}Messages{% endblock %}
{% block marketplace_header %}{% endblock %}
{% block marketplace_subtitle %}{% endblock %}

{% block breadcrumbs %}{% endblock %}

{% block marketplace_content %}
<style>
  /* Message composer layout and usability fixes */
  #messageForm { position: sticky; bottom: 0; background: transparent; }
  #messageInput { resize: none; min-height: 3.25rem; max-height: 14rem; overflow-y: auto; }
  #sendButton { align-self: flex-end; width: 2.75rem; height: 2.75rem; flex: 0 0 auto; }
</style>
<!-- Integration Banner: concise status + primary actions -->
<div id="integrationBanner" class="alert alert-info hidden">
  <div class="flex items-center gap-2 w-full">
    <i class="fas fa-link"></i>
    <span id="integrationBannerText" class="text-sm">This conversation is tied to a purchase request.</span>
    <div class="ml-auto flex items-center gap-2">
      <a id="ctaStartRequest" href="#" class="btn btn-ghost btn-sm hidden">Start Request</a>
      <a id="ctaViewRequest" href="#" class="btn btn-primary btn-sm hidden">View Request</a>
    </div>
  </div>
</div>

<!-- Mobile Sidebar Toggle -->
<div class="flex items-center gap-2 mb-2 lg:hidden">
  <button id="sidebarToggleBtn" class="btn btn-ghost btn-square" aria-label="Open sidebar" aria-controls="conversationSidebar" aria-expanded="false">
    <i class="fas fa-bars"></i>
  </button>
  <span class="text-sm text-base-content/70">Conversations</span>
</div>
<div id="sidebarOverlay" class="fixed inset-0 z-40 bg-black/40 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out lg:hidden"></div>

<!-- Main Layout: Sidebar + Chat -->
<div class="h-[calc(100vh-200px)] flex flex-col lg:flex-row gap-4">
  <!-- Conversations Sidebar -->
  <aside id="conversationSidebar" class="w-80 max-w-[85vw] lg:w-1/3 bg-base-200 rounded-xl flex flex-col fixed inset-y-0 left-0 z-50 transform -translate-x-full transition-transform duration-300 ease-in-out lg:static lg:translate-x-0 lg:z-auto" role="complementary" aria-label="Conversations Sidebar">
    <!-- Sidebar Header -->
    <div class="p-4 border-b border-base-300">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-xl font-bold">Conversations</h2>
        <div class="flex items-center gap-2">
          <button class="btn btn-ghost btn-sm" onclick="refreshConversations()" title="Refresh">
            <i class="fas fa-sync-alt"></i>
          </button>
        </div>
      </div>
      <!-- Search Conversations -->
      <div class="form-control">
        <div class="input-group">
          <input type="text" placeholder="Search conversations..." class="input input-bordered input-sm flex-1" id="conversationSearch" aria-label="Search conversations">
          <button class="btn btn-square btn-sm" onclick="applyConversationFilter()" aria-label="Search"><i class="fas fa-search"></i></button>
        </div>
      </div>
    </div>
    <!-- Conversations List -->
    <div class="flex-1 overflow-y-auto" id="conversationsList" aria-live="polite" aria-busy="false">
      <!-- Loading skeletons shown by JS when fetching -->
      <div class="p-4 text-sm text-base-content/60">Start a conversation from a listing to see it here.</div>
    </div>
  </aside>

  <!-- Chat Window -->
  <section class="flex-1 bg-base-200 rounded-xl flex flex-col">
    <!-- Chat Header -->
    <div class="p-4 border-b border-base-300" id="chatHeader">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <div class="avatar placeholder">
            <div class="bg-neutral text-neutral-content rounded-full w-9">
              <span id="headerAvatarChar" class="text-sm">?</span>
            </div>
          </div>
          <div>
            <h3 class="font-semibold" id="chatUsername">Messages</h3>
            <p class="text-sm text-base-content/70" id="chatProduct">No conversation selected. Choose a listing to start messaging.</p>
          </div>
        </div>
        <div class="flex items-center gap-2">
          <span id="headerRequestBadge" class="badge badge-primary hidden">Request</span>
          <button class="btn btn-ghost btn-sm" onclick="fetchMessages(0)" title="Fetch latest"><i class="fas fa-download"></i></button>
        </div>
      </div>
      <div id="typingIndicator" class="mt-2 text-xs text-base-content/70 hidden">
        <i class="fas fa-ellipsis-h animate-pulse mr-1"></i> You are typing...
      </div>
    </div>

    <!-- Messages Area -->
    <div class="flex-1 overflow-y-auto p-4 space-y-4" id="messagesArea" aria-live="polite" aria-busy="false"></div>

    <!-- Empty State -->
    <div id="emptyChatState" class="p-8 text-center hidden">
      <div class="flex flex-col items-center gap-3">
        <div class="avatar placeholder">
          <div class="bg-base-300 text-base-content rounded-full w-16">
            <i class="fas fa-comments text-xl"></i>
          </div>
        </div>
        <h4 class="text-lg font-semibold">No messages yet</h4>
        <p class="text-sm text-base-content/70">Start a conversation or select an existing one from the sidebar.</p>
      </div>
    </div>

    <!-- Message Input -->
    <form id="messageForm" class="p-4 border-t border-base-300 flex items-end gap-3">
      <div class="flex-1">
        <textarea id="messageInput" class="textarea textarea-bordered textarea-md w-full" placeholder="Type a message (Enter to send, Shift+Enter for newline)" rows="2" maxlength="4000" aria-label="Message input"></textarea>
        <div class="flex items-center justify-between mt-1">
          <div class="text-xs text-base-content/60">Press Enter to send</div>
          <div id="charCount" class="text-xs text-base-content/60">0 / 4000</div>
        </div>
      </div>
      <button id="sendButton" type="submit" class="btn btn-primary btn-circle btn-sm flex-none" disabled aria-disabled="true" aria-label="Send message" title="Send">
        <i class="fas fa-paper-plane"></i>
      </button>
    </form>
  </section>
</div>

<script>
// ===== Messaging Client Logic (Preserves existing endpoints) =====
let currentThreadId = null;
let lastMessageId = 0;
let currentUserId = {{ current_user_id|default:"null" }};
let currentUsername = "{{ current_username|default:"" }}";
let currentRequestId = null;
let conversations = [];
let listingTitleCache = {};
let conversationFilterDebounced = null;

/**
 * Get CSRF token from cookie for safe POST requests.
 * Returns an empty string if not found; callers must set header conditionally.
 */
function getCSRFToken() {
  const name = 'csrftoken=';
  const cookies = document.cookie.split(';');
  for (let c of cookies) {
    c = c.trim();
    if (c.startsWith(name)) return c.substring(name.length);
  }
  return '';
}

/**
 * Auto-resize the textarea and toggle send button based on trimmed content.
 * Also updates the character counter.
 * @param {HTMLTextAreaElement} el
 */
function autoResize(el) {
  el.style.height = 'auto';
  el.style.height = (el.scrollHeight) + 'px';
  const hasText = !!el.value.trim();
  setSendEnabled(!!currentThreadId);
  updateCharCount(el);
  toggleTypingIndicator(hasText);
}

/**
 * Update the visible character counter beneath the message input.
 * @param {HTMLTextAreaElement} el
 */
function updateCharCount(el) {
  const counter = document.getElementById('charCount');
  if (!counter) return;
  counter.textContent = `${el.value.length} / ${el.maxLength}`;
}

/**
 * Light typing indicator toggled from local input state.
 * Remote typing would require websockets; we keep it local-only.
 * @param {boolean} isTyping
 */
function toggleTypingIndicator(isTyping) {
  const el = document.getElementById('typingIndicator');
  if (!el) return;
  el.classList.toggle('hidden', !isTyping);
}

/**
 * Render a single message bubble based on sender alignment with avatar.
 * Handles pending state (optimistic UI) and simple time formatting.
 * @param {Object} msg
 * @returns {string}
 */
function renderMessageBubble(msg) {
  const isMe = msg.sender_id === currentUserId;
  const sideClass = isMe ? 'chat-end' : 'chat-start';
  const bubbleClass = isMe ? 'chat-bubble-secondary' : 'chat-bubble-primary';
  const avatarBg = isMe ? 'bg-secondary text-secondary-content' : 'bg-primary text-primary-content';
  const headerName = isMe ? 'You' : `@${msg.sender_username || 'user'}`;
  const createdAt = msg.created_at ? new Date(msg.created_at) : new Date();
  const timeText = createdAt.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
  const pendingClass = msg.pending ? 'opacity-70' : '';
  const pendingSpinner = msg.pending ? '<span class="loading loading-spinner loading-xs ml-2" aria-label="Sending"></span>' : '';
  const avatarChar = (msg.sender_username || 'U')[0].toUpperCase();
  return `
    <div class="chat ${sideClass}" data-temp-id="${msg.tempId || ''}">
      <div class="chat-image avatar">
        <div class="w-8 rounded-full ${avatarBg} flex items-center justify-center">
          <span class="text-xs">${avatarChar}</span>
        </div>
      </div>
      <div class="chat-header">${headerName}<time class="text-xs opacity-50 ml-2">${timeText}</time></div>
      <div class="chat-bubble ${bubbleClass} ${pendingClass}">${msg.content}${pendingSpinner}</div>
    </div>`;
}

/**
 * Render messages into the chat area with simple windowing (last 200 messages).
 * @param {Array} messages
 * @param {Object} opts
 */
function renderMessages(messages, {append = false} = {}) {
  const area = document.getElementById('messagesArea');
  if (!area) return;
  document.getElementById('emptyChatState')?.classList.add('hidden');
  let html = append ? area.innerHTML : '';
  const startIndex = Math.max(0, messages.length - 200);
  const windowed = messages.slice(startIndex);
  for (const m of windowed) {
    html += renderMessageBubble(m);
    if (m.id && m.id > lastMessageId) lastMessageId = m.id;
  }
  area.innerHTML = html;
  area.scrollTop = area.scrollHeight;
}

/**
 * Append an optimistic, pending message bubble to the DOM.
 * @param {string} tempId
 * @param {string} content
 */
function appendOptimisticMessage(tempId, content) {
  const area = document.getElementById('messagesArea');
  const msg = {
    id: null,
    tempId,
    pending: true,
    sender_id: currentUserId,
    sender_username: currentUsername,
    content,
    created_at: new Date().toISOString()
  };
  area.innerHTML += renderMessageBubble(msg);
  area.scrollTop = area.scrollHeight;
}

/**
 * Remove an optimistic message by its temporary id.
 * @param {string} tempId
 */
function removePendingMessage(tempId) {
  const area = document.getElementById('messagesArea');
  const el = area.querySelector(`[data-temp-id="${tempId}"]`);
  if (el) el.remove();
}

/**
 * Start or get a thread for a given listing_id via REST.
 * Preserves existing endpoint: /marketplace/api/messages/thread/start/
 * @param {number|string} listingId
 */
async function startOrGetThread(listingId) {
  const resp = await fetch('/marketplace/api/messages/thread/start/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
    body: JSON.stringify({listing_id: parseInt(listingId, 10)})
  });
  if (!resp.ok) { showMarketplaceToast('Failed to start conversation.', 'error'); return; }
  const data = await resp.json();
  currentThreadId = data.thread.id;
  currentRequestId = data.thread && typeof data.thread.request_id !== 'undefined' ? data.thread.request_id : null;
  lastMessageId = 0;
  renderMessages(data.messages || [], {append: false});
  updateIntegrationBanner(data.thread.listing_id);
  // Update header with participant and product
  updateChatHeader({
    buyer: { id: data.thread.buyer_id, username: data.thread.buyer_username },
    seller: { id: data.thread.seller_id, username: data.thread.seller_username },
    listing_id: data.thread.listing_id
  });
  try {
    const title = await getListingTitle(data.thread.listing_id);
    updateChatProduct(title, data.thread.listing_id);
  } catch (_) {}
  updateHeaderBadges();
  try { await refreshConversations(); } catch (_) {}
  setSendEnabled(true);
}

/**
 * Fetch messages for the current thread, optionally after a specific id.
 * @param {number} afterId
 */
async function fetchMessages(afterId = 0) {
  if (!currentThreadId) return;
  const url = `/marketplace/api/messages/thread/${currentThreadId}/messages/?after_id=${afterId}&limit=50`;
  const area = document.getElementById('messagesArea');
  area?.setAttribute('aria-busy', 'true');
  const resp = await fetch(url, {method: 'GET'});
  area?.setAttribute('aria-busy', 'false');
  if (!resp.ok) return;
  const data = await resp.json();
  if (typeof data.request_id !== 'undefined') {
    currentRequestId = data.request_id;
    updateIntegrationBanner();
    updateHeaderBadges();
  }
  if (Array.isArray(data.messages) && data.messages.length) {
    renderMessages(data.messages, {append: true});
  } else {
    showEmptyStateIfNoMessages();
  }
}

/** Poll for new messages every few seconds. */
function pollNewMessages() { fetchMessages(lastMessageId); }

/**
 * Send a message via REST POST with optimistic UI.
 */
async function sendMessage() {
  const messageInput = document.getElementById('messageInput');
  const sendButton = document.getElementById('sendButton');
  const content = (messageInput.value || '').trim();
  if (!content) return;
  if (!currentThreadId) { showMarketplaceToast('No active conversation.', 'error'); return; }
  sendButton.disabled = true;
  sendButton.setAttribute('aria-disabled', 'true');

  const tempId = `tmp_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  appendOptimisticMessage(tempId, content);

  try {
    const resp = await fetch(`/marketplace/api/messages/thread/${currentThreadId}/post/`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRFToken': getCSRFToken() },
      body: JSON.stringify({content})
    });
    if (!resp.ok) {
      removePendingMessage(tempId);
      showMarketplaceToast('Failed to send message.', 'error');
      return;
    }
    showMarketplaceToast('Message sent', 'success');
    try { await fetchMessages(lastMessageId); } catch (_) {}
    removePendingMessage(tempId);
    messageInput.value = '';
    messageInput.style.height = 'auto';
    updateCharCount(messageInput);
    toggleTypingIndicator(false);
    sendButton.disabled = true;
    sendButton.setAttribute('aria-disabled', 'true');
  } catch (e) {
    removePendingMessage(tempId);
    showMarketplaceToast('Network error sending message.', 'error');
  } finally {
    sendButton.disabled = !messageInput.value.trim();
    sendButton.setAttribute('aria-disabled', (!messageInput.value.trim()) ? 'true' : 'false');
  }
}

/**
 * Initialize messaging based on URL query params for thread or listing.
 */
function initThreadFromQuery() {
  const params = new URLSearchParams(window.location.search);
  const listingId = params.get('listing_id');
  const threadId = params.get('thread_id');
  if (threadId) {
    currentThreadId = parseInt(threadId, 10);
    lastMessageId = 0;
    fetchThreadSummary(currentThreadId).then(async (thread) => {
      updateChatHeader(thread);
      try {
        const title = await getListingTitle(thread.listing_id);
        updateChatProduct(title, thread.listing_id);
      } catch (_) {}
      updateHeaderBadges();
    }).catch(() => {});
    fetchMessages(0);
    setSendEnabled(true);
    return;
  }
  if (listingId) {
    startOrGetThread(listingId);
    const banner = document.getElementById('integrationBanner');
    if (banner) banner.classList.remove('hidden');
    return;
  }
  // No context: show empty state
  showEmptyStateIfNoMessages();
  setSendEnabled(false);
}

/**
 * Update integration banner and CTAs based on whether a request exists.
 * @param {number|null} listingId
 */
function updateIntegrationBanner(listingId = null) {
  const banner = document.getElementById('integrationBanner');
  const text = document.getElementById('integrationBannerText');
  const ctaStart = document.getElementById('ctaStartRequest');
  const ctaView = document.getElementById('ctaViewRequest');
  const headerBadge = document.getElementById('requestBadge');
  if (!banner || !text || !ctaStart || !ctaView) return;
  if (listingId) { ctaStart.href = `/marketplace/listing/${parseInt(listingId, 10)}/`; }
  if (currentRequestId) {
    text.textContent = 'This conversation is tied to a purchase request.';
    ctaView.href = `/marketplace/request/${currentRequestId}/`;
    ctaView.classList.remove('hidden');
    ctaStart.classList.add('hidden');
    headerBadge?.classList.remove('hidden');
  } else {
    text.textContent = 'Discuss here or start a purchase request for this listing.';
    ctaView.classList.add('hidden');
    ctaStart.classList.remove('hidden');
    headerBadge?.classList.add('hidden');
  }
  banner.classList.remove('hidden');
}

/**
 * Fetch thread summary via REST to populate header.
 * @param {number} threadId
 */
async function fetchThreadSummary(threadId) {
  const resp = await fetch(`/marketplace/api/threads/${threadId}/`, { method: 'GET' });
  if (!resp.ok) throw new Error('Failed to fetch thread');
  const data = await resp.json();
  return data;
}

/**
 * Cache and return listing title for rendering sidebar and header.
 * @param {number} listingId
 */
async function getListingTitle(listingId) {
  const key = String(listingId);
  if (listingTitleCache[key]) return listingTitleCache[key];
  const resp = await fetch(`/marketplace/api/listings/${listingId}/`, { method: 'GET' });
  if (!resp.ok) throw new Error('Listing not found');
  const data = await resp.json();
  listingTitleCache[key] = data.title || `Listing #${listingId}`;
  return listingTitleCache[key];
}

/**
 * Update chat header username based on the other participant.
 * @param {Object} thread
 */
function updateChatHeader(thread) {
  const headerEl = document.getElementById('chatUsername');
  const avatarCharEl = document.getElementById('headerAvatarChar');
  if (!headerEl || !thread) return;
  const other = (thread.buyer && thread.buyer.id === currentUserId) ? thread.seller : thread.buyer;
  const name = other && other.username ? `@${other.username}` : 'Conversation';
  headerEl.textContent = name;
  avatarCharEl.textContent = (other && other.username ? other.username[0] : '?').toUpperCase();
}

/**
 * Update the product label under the header using listing title.
 * @param {string} title
 * @param {number} listingId
 */
function updateChatProduct(title, listingId) {
  const prodEl = document.getElementById('chatProduct');
  if (!prodEl) return;
  const safeTitle = title || `Listing #${listingId}`;
  prodEl.textContent = `Listing: ${safeTitle}`;
}

/** Update header badges to reflect request linkage. */
function updateHeaderBadges() {
  const headerBadge = document.getElementById('headerRequestBadge');
  if (!headerBadge) return;
  headerBadge.classList.toggle('hidden', !currentRequestId);
}

/** Enable/disable the send button based on thread selection and input. */
function setSendEnabled(enabled) {
  const sendButton = document.getElementById('sendButton');
  const input = document.getElementById('messageInput');
  const hasText = !!input.value.trim();
  sendButton.disabled = !(enabled && hasText);
  sendButton.setAttribute('aria-disabled', sendButton.disabled ? 'true' : 'false');
}

/** Show empty chat state when no messages are available. */
function showEmptyStateIfNoMessages() {
  const area = document.getElementById('messagesArea');
  const empty = document.getElementById('emptyChatState');
  if (!area || !empty) return;
  if (!area.innerHTML.trim()) empty.classList.remove('hidden');
}

// ----- Sidebar helpers -----

/**
 * Fetch and render conversations for the sidebar, ordered by last_message_at.
 */
async function refreshConversations() {
  const listEl = document.getElementById('conversationsList');
  if (!listEl) return;
  listEl.setAttribute('aria-busy', 'true');
  renderSkeletonConversations(listEl);
  try {
    const resp = await fetch('/marketplace/api/threads/?ordering=-last_message_at', { method: 'GET' });
    if (!resp.ok) { throw new Error('Failed to load conversations'); }
    const data = await resp.json();
    conversations = Array.isArray(data) ? data : (Array.isArray(data.results) ? data.results : []);
    renderConversations(conversations);
  } catch (e) {
    listEl.innerHTML = '<div class="p-4 text-sm text-error">Failed to load conversations.</div>';
  } finally {
    listEl.setAttribute('aria-busy', 'false');
  }
}

/**
 * Render conversation list items with avatars, status dots, and last activity.
 * @param {Array} threads
 */
function renderConversations(threads) {
  const listEl = document.getElementById('conversationsList');
  if (!listEl) return;
  if (!threads.length) {
    listEl.innerHTML = '<div class="p-4 text-sm text-base-content/60">Start a conversation from a listing to see it here.</div>';
    return;
  }
  let html = '';
  const now = Date.now();
  threads.forEach((t) => {
    const other = (t.buyer && t.buyer.id === currentUserId) ? t.seller : t.buyer;
    const name = other && other.username ? `@${other.username}` : 'Conversation';
    const lastAt = t.last_message_at ? new Date(t.last_message_at).toLocaleString() : '';
    const avatarChar = (other && other.username ? other.username[0] : '?').toUpperCase();
    const recent = t.last_message_at ? (now - new Date(t.last_message_at).getTime()) < (5 * 60 * 1000) : false;
    const statusDot = recent ? 'bg-green-500' : 'bg-base-300';
    html += `
      <div class="p-3 border-b border-base-300 hover:bg-base-300 cursor-pointer" data-thread-id="${t.id}" onclick="openThreadFromList(${t.id})">
        <div class="flex items-center gap-3">
          <div class="avatar">
            <div class="w-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center relative">
              <span class="text-xs">${avatarChar}</span>
              <span class="absolute -bottom-0 -right-0 w-2 h-2 rounded-full ${statusDot}"></span>
            </div>
          </div>
          <div class="flex-1">
            <div class="flex items-center justify-between">
              <div class="font-medium">${name}</div>
              <div class="text-xs text-base-content/60">${lastAt}</div>
            </div>
            <div class="text-xs text-base-content/70">Listing: <span class="listing-title-${t.listing_id}">Listing #${t.listing_id}</span></div>
          </div>
        </div>
      </div>`;
  });
  listEl.innerHTML = html;
  threads.forEach(async (t) => {
    try {
      const title = await getListingTitle(t.listing_id);
      const el = listEl.querySelector(`.listing-title-${t.listing_id}`);
      if (el) el.textContent = title;
    } catch (_) {}
  });
}

/**
 * Open a thread from the sidebar list and hydrate header and messages.
 * @param {number} threadId
 */
function openThreadFromList(threadId) {
  const t = conversations.find(x => x.id === threadId);
  currentThreadId = threadId;
  lastMessageId = 0;
  if (t) {
    updateChatHeader(t);
    getListingTitle(t.listing_id).then((title) => { updateChatProduct(title, t.listing_id); }).catch(() => {});
  }
  document.getElementById('messagesArea').innerHTML = '';
  document.getElementById('emptyChatState')?.classList.add('hidden');
  fetchMessages(0);
  updateIntegrationBanner();
  updateHeaderBadges();
  setSendEnabled(true);
}

/** Debounce utility to limit rapid calls (e.g., search input). */
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

/** Apply conversation filter by current input value. */
function applyConversationFilter() { filterConversations(); }

/**
 * Filter sidebar conversations by text content.
 */
function filterConversations() {
  const q = (document.getElementById('conversationSearch')?.value || '').toLowerCase();
  const listEl = document.getElementById('conversationsList');
  if (!listEl) return;
  const items = listEl.querySelectorAll('[data-thread-id]');
  items.forEach((item) => {
    const text = item.textContent.toLowerCase();
    item.style.display = text.includes(q) ? '' : 'none';
  });
}

/** Show skeleton loaders in the conversation list while fetching. */
function renderSkeletonConversations(listEl) {
  listEl.innerHTML = Array.from({length: 6}).map(() => `
    <div class="p-3 border-b border-base-300">
      <div class="flex items-center gap-3">
        <div class="skeleton w-8 h-8 rounded-full"></div>
        <div class="flex-1">
          <div class="skeleton h-3 w-1/2 mb-2"></div>
          <div class="skeleton h-3 w-1/3"></div>
        </div>
      </div>
    </div>`).join('');
}

// ----- Poller, Idle detection, and Mobile sidebar -----

let pollTimer = null;
let currentPollInterval = 3000;

/** Start the periodic poller for new messages. */
function startPoller(intervalMs) {
  currentPollInterval = intervalMs;
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = setInterval(() => { pollNewMessages(); }, currentPollInterval);
}

/** Update the poller interval, restarting if changed. */
function updatePoller(intervalMs) {
  if (intervalMs === currentPollInterval) return;
  startPoller(intervalMs);
}

let idleTimer = null;
const idleThresholdMs = 60000; // 60s of inactivity

/** Reset idle timer and adjust poller intervals based on tab visibility. */
function resetIdleTimer() {
  if (idleTimer) clearTimeout(idleTimer);
  updatePoller(document.hidden ? 15000 : 3000);
  idleTimer = setTimeout(() => {
    if (!document.hidden) { updatePoller(6000); }
  }, idleThresholdMs);
}

/** Attach listeners to detect idle state. */
function setupIdleDetection() {
  ['mousemove', 'keydown', 'touchstart'].forEach(evt => { document.addEventListener(evt, resetIdleTimer); });
  resetIdleTimer();
}

/** Setup mobile sidebar toggle handlers. */
function setupSidebarToggle() {
  const toggleBtn = document.getElementById('sidebarToggleBtn');
  const overlay = document.getElementById('sidebarOverlay');
  const sidebar = document.getElementById('conversationSidebar');
  if (!toggleBtn || !overlay || !sidebar) return;
  const openSidebar = () => {
    sidebar.classList.remove('-translate-x-full');
    overlay.classList.remove('opacity-0', 'pointer-events-none');
    overlay.classList.add('opacity-100');
    toggleBtn.setAttribute('aria-expanded', 'true');
  };
  const closeSidebar = () => {
    sidebar.classList.add('-translate-x-full');
    overlay.classList.add('opacity-0', 'pointer-events-none');
    overlay.classList.remove('opacity-100');
    toggleBtn.setAttribute('aria-expanded', 'false');
  };
  toggleBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if (window.matchMedia('(max-width: 1023px)').matches) {
      const isOpen = toggleBtn.getAttribute('aria-expanded') === 'true';
      isOpen ? closeSidebar() : openSidebar();
    }
  });
  overlay.addEventListener('click', closeSidebar);
}

// ----- Bootstrapping -----

window.addEventListener('DOMContentLoaded', () => {
  // Send handler
  document.getElementById('messageForm').addEventListener('submit', (e) => { e.preventDefault(); sendMessage(); });
  // Auto-resize and typing indicator
  const input = document.getElementById('messageInput');
  input.addEventListener('input', function() { autoResize(this); });
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });
  // Initialize composer state
  autoResize(input);
  setSendEnabled(false);
  // Debounced search
  conversationFilterDebounced = debounce(filterConversations, 200);
  document.getElementById('conversationSearch').addEventListener('input', conversationFilterDebounced);
  // Init thread context
  initThreadFromQuery();
  // Start poller and idle detection
  startPoller(3000);
  setupIdleDetection();
  // Load conversations
  refreshConversations();
  // Mobile sidebar toggle
  setupSidebarToggle();
});
</script>
{% endblock %}